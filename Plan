Video source:
    https://www.youtube.com/watch?v=9vvtO0S1KlY&list=PL0Zuz27SZ-6PrE9srvEn8nbhOOyxnWXfp&index=13&ab_channel=DaveGray

Створимо папку data, куди додамо файл db.json :

    { 
        "items": [
            {
                "id": 1,
                "checked": false,
                "item": "Tomatoes"
            },
            {
                "id": 2,
                "checked": false,
                "item": "Orange Juice"
            },
            {
                "id": 3,
                "checked": false,
                "item": "Ice-Cream"
            }
        ]
    }

Відкрити нове вікно терміналу (bash) і ввести команду :

    npx json-server -p 3500 -w data/db.json

    (npx - node package executer, -p - port, -w - watch)

Тепер можна працювати як і з іншим сервером (get/put/delete)  
Відобразити інфу : localhost:3500/items  

В Арр створимо змінну з нашим АРІ:

    const API_URL = "http://localhost:3500/items";

Так як у нас вже є АРІ, тепер можна отримувати інформацію не з localStorage, а з АРІ
Для цього змінимо наш useEffect і по стандарту він працював би так :

    useEffect (()=> {
        const fetchItem = async () => {
            const response = await fetch(API_URL);
            const listItems = await response.json();
            setItems(listItems)
        }
    },[]);

 І змінимо useState нашого ключового масиву items:
 
    const [items,setItems] = useState([]);

Однак у нас є імовірність помилки від сервера, тому в запит треба додати блоки try/catch і useEffect для помилок:

const [setError, setFetchError] = useState(null);

useEffect (()=> {
  const fetchItem = async () => {
    try {
      const response = await fetch(API_URL);
      if (!response.ok) throw Error("Did not received expected data");
      const listItems = await response.json();
      setItems(listItems);
      setFetchError(null)
    } catch (err) {
      setFetchError(err.message)
    }
  }
  fetchItem()
},[]);

І у випадку якщо помилка буде, виведемо її вище компоненту Content:

    {fetchError && <p style={{color:"red",margin:"20px 10px"}}>{`Error: ${fetchError}`}</p>}
    {!fetchError && <Content
    items={items.filter(item => ((item.item).toLowerCase()).includes(search.toLowerCase()))}
    setItems={setItems}
    handleCheck={handleCheck}
    handleDelete={handleDelete}
    />}
    </main>

Так як наш локальний сервер завантажує швидко, а насправді це може зайняти трохи часу, то зімітуємо завантаження нашого списку items на 2 секунди і пропишемо "Loading Items..." на екрані протягом цих 2-х секунд. Для цього створимо новий useState:

    const [isLoading,setIsLoading] = useState(true);

Пропишемо затримку в 2с в нашому useEffect:

    useEffect (()=> {
        const fetchItem = async () => {
        try {
            const response = await fetch(API_URL);
            if (!response.ok) throw Error("Did not receive expected data");
            const listItems = await response.json();
            setItems(listItems);
            setFetchError(null)
        } catch (err) {
            setFetchError(err.message)
        } finally {
            setIsLoading(false)
        }
        }
--->    setTimeout(()=> {
        fetchItem()
        },2000)
    },[]);

І виведемо "Loading Items..." в JSX під час завантаження:

    <main>
--->    {isLoading && <p>Loading Items...</p>}
        {fetchError && <p style={{color:"red",margin:"20px 10px"}}>{`Error: ${fetchError}`}</p>}
--->    {!fetchError && !isLoading && <Content
        items={items.filter(item => ((item.item).toLowerCase()).includes(search.toLowerCase()))}
        setItems={setItems}
        handleCheck={handleCheck}
        handleDelete={handleDelete}
        />}
    </main>


 







